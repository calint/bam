# view assembler
~/.platformio/packages/toolchain-xtensa-esp32/bin/xtensa-esp32-elf-objdump -S .pio/build/esp32dev/src/main.cpp.o | less

# stack trace. copy 'back trace' addresses as argument
~/.platformio/packages/toolchain-xtensa-esp32/bin/xtensa-esp32-elf-addr2line -pfiaC -e .pio/build/esp32dev/firmware.elf  0x400D2230:0x3FFD7CB0 0x400D846A:0x3FFD7CE0

# revert changes to last commit
git reset --hard HEAD

# commit and push
git add . && git commit -m "." && git push

# tag with date and time
TAG=$(date "+%Y-%m-%d--%H-%M") && git tag $TAG && git push origin $TAG

# stack trace
#include "esp_debug_helpers.h"
esp_backtrace_print(10);







//
// render one scan line at a time, fps ~23
//
static void render(const int x, const int y) {
  display.startWrite();
  // extract whole number and fractions from x, y
  const int tile_x = x >> tile_width_shift;
  const int tile_x_fract = x & tile_width_and;
  int tile_y = y >> tile_height_shift;
  int tile_y_fract = y & tile_height_and;
  // selects buffer to write while DMA reads the other buffer
  bool dma_buf_use_first = true;
  // destination display y for buffer transfer using DMA
  int addr_win_y = 0;
  // current screen y for scanline
  int16_t scanline_y = 0;
  // pointer to start of current row of tiles
  tile_ix const *tiles_map_row_ptr = tile_map[tile_y];
  // pointer to collision map starting at top left of screen
  sprite_ix *collision_map_row_ptr = collision_map;
  // for all lines on display
  int remaining_y = display_height;
  while (remaining_y) {
    // swap between two rendering buffers to not overwrite DMA used
    // buffer
    uint16_t *render_buf_ptr = dma_buf_use_first ? dma_buf_1 : dma_buf_2;
    dma_buf_use_first = not dma_buf_use_first;
    // pointer to the buffer that DMA will copy to screen
    uint16_t *dma_buf = render_buf_ptr;
    // render from tiles map and sprites to the 'render_buf_ptr'
    int render_n_tile_lines =
        remaining_y < tile_height ? remaining_y : tile_height;
    // prepare loop variables
    int render_n_scanlines = 0;
    int tile_line = 0;
    int tile_line_times_tile_width = 0;
    if (tile_y_fract) {
      render_n_scanlines = tile_height - tile_y_fract;
      tile_line = tile_y_fract;
      tile_line_times_tile_width = tile_y_fract * tile_height;
      tile_y_fract = 0;
    } else {
      render_n_scanlines = render_n_tile_lines;
      tile_line = 0;
      tile_line_times_tile_width = 0;
    }
    // render a row from tile map
    while (tile_line < render_n_tile_lines) {
      render_scanline(render_buf_ptr, collision_map_row_ptr, tile_x,
                      tile_x_fract, tiles_map_row_ptr, scanline_y,
                      tile_line_times_tile_width);
      tile_line++;
      tile_line_times_tile_width += tile_width;
      // render_buf_ptr += display_width;
      collision_map_row_ptr += display_width;
      scanline_y++;
      display.setAddrWindow(0, addr_win_y, display_width, 1);
      display.pushPixelsDMA(dma_buf, unsigned(display_width));
      render_buf_ptr = dma_buf_use_first ? dma_buf_1 : dma_buf_2;
      dma_buf_use_first = not dma_buf_use_first;
      addr_win_y++;
      dma_buf = render_buf_ptr;
    }
    // display.setAddrWindow(0, addr_win_y, display_width, render_n_scanlines);
    // display.pushPixelsDMA(dma_buf,
    //                       unsigned(display_width * render_n_scanlines));
    tile_y++;
    // addr_win_y += render_n_scanlines;
    remaining_y -= render_n_scanlines;
    tiles_map_row_ptr += tile_map_width;
  }
  display.endWrite();
}
